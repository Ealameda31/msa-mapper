{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MSA Mapper \u00b6 msa_mapper helps users geocode addresses and map them to defined geometric boundaries to easily aggregate statistics and standardize insights across geopolitical regions. Info Only Metropolitan Statistical Areas (MSAs) defined by the Census Bureau are currently supported in this release, but the developers plan on adding other defined regions over time. Getting Started \u00b6 To set up an environment with the library installed, follow the instructions outlined within the Git repository . Visit the Modules section for comprehensive documentation on library modules and their corresponding functions. Understand how to call the functions and use them in conjunction by visiting the Use-Cases sub-section of this page. Useful Links \u00b6 Links to follow for novices at Git or Python to troubleshoot installation issues: Primer on Python virtual environments GitHub and SSH keys Installing Python wheels locally","title":"Home"},{"location":"#msa-mapper","text":"msa_mapper helps users geocode addresses and map them to defined geometric boundaries to easily aggregate statistics and standardize insights across geopolitical regions. Info Only Metropolitan Statistical Areas (MSAs) defined by the Census Bureau are currently supported in this release, but the developers plan on adding other defined regions over time.","title":"MSA Mapper"},{"location":"#getting-started","text":"To set up an environment with the library installed, follow the instructions outlined within the Git repository . Visit the Modules section for comprehensive documentation on library modules and their corresponding functions. Understand how to call the functions and use them in conjunction by visiting the Use-Cases sub-section of this page.","title":"Getting Started"},{"location":"#useful-links","text":"Links to follow for novices at Git or Python to troubleshoot installation issues: Primer on Python virtual environments GitHub and SSH keys Installing Python wheels locally","title":"Useful Links"},{"location":"home/use_cases/","text":"Use-Cases \u00b6 The Python library, msa_mapper , contains two modules: Geographic Decoder Census MSA Mapping These modules each serve a specific purpose but can be combined to provide geopolitical regions for any location. To accomplish this, users can follow the workflow below: graph LR A[Obtain addresses] --> B[Acquire lat/lon coords via Geocoder]; B --> C[Map coords to regions via Census mapper]; Simple Python code is provided below to reproduce this workflow: # Importing libraries import pandas as pd from msa_mapper import ( get_geoinfo , map_census_locations ) # Reading CSV file with addresses addresses_pdf = pd . read_csv ( 'addresses.csv' ) # Acquiring lat/lon coords using an assumed \"Address\" column addresses_pdf [ 'coords' ] = ( addresses_pdf . apply ( lambda x : get_geoinfo ( x . Address )[ 1 ], axis = 1 ) ) # Mapping coordinates to regions addresses_pdf [ 'MSA_regions' ] = ( map_census_locations ( addresses_pdf . coords . tolist ()) . MSA_Name . values )","title":"Use-Cases"},{"location":"home/use_cases/#use-cases","text":"The Python library, msa_mapper , contains two modules: Geographic Decoder Census MSA Mapping These modules each serve a specific purpose but can be combined to provide geopolitical regions for any location. To accomplish this, users can follow the workflow below: graph LR A[Obtain addresses] --> B[Acquire lat/lon coords via Geocoder]; B --> C[Map coords to regions via Census mapper]; Simple Python code is provided below to reproduce this workflow: # Importing libraries import pandas as pd from msa_mapper import ( get_geoinfo , map_census_locations ) # Reading CSV file with addresses addresses_pdf = pd . read_csv ( 'addresses.csv' ) # Acquiring lat/lon coords using an assumed \"Address\" column addresses_pdf [ 'coords' ] = ( addresses_pdf . apply ( lambda x : get_geoinfo ( x . Address )[ 1 ], axis = 1 ) ) # Mapping coordinates to regions addresses_pdf [ 'MSA_regions' ] = ( map_census_locations ( addresses_pdf . coords . tolist ()) . MSA_Name . values )","title":"Use-Cases"},{"location":"modules/census_msa/","text":"Census MSA Mapping \u00b6 map_census_locations ( coords ) \u00b6 Given a list of longitude/latitude coordinate pairs or a single pair, this function will map the locations to the census-defined Metropolitan Statistical Area (MSA). Parameters: Name Type Description Default coords tuple or list[tuple] either a single coordinate pair or a list of longitude/latitude coordinates required Returns: This function returns a geopandas.geodataframe.GeoDataFrame with the following columns Column Type Description Coordinates shapely.geometry.Point coordinates passed to the function as a shapely geometry MSA_Name str name given by the census to the MSA mapped to the coordinate pair MSA_Fip_Code str code given by the census to describe the coordinate pair area - useful when mapping to other sources Exceptions: Type Description ValueError Coordinates must either be a list of tuples with two floats in each element or a single tuple with two floats. Examples: Function can be applied to a single coordinate pair or a list of coordinates and is robust to empty values: >>> from msa_mapper import map_census_locations >>> dc_lonlat = ( - 77.03637 , 38.9072 ) >>> map_census_locations ( dc_lonlat ) Source code in msa_mapper/census_msa.py def map_census_locations ( coords ): \"\"\" Given a list of longitude/latitude coordinate pairs or a single pair, this function will map the locations to the census-defined Metropolitan Statistical Area (MSA). Args: coords (tuple or list[tuple]): either a single coordinate pair or a list of longitude/latitude coordinates **Returns:** This function returns a geopandas.geodataframe.GeoDataFrame with the following columns | Column | Type | Description | | :----- | :--- | :---------- | | Coordinates | `shapely.geometry.Point`| coordinates \\ passed to the function as a shapely geometry | | MSA_Name | `str` | name given by the census to the MSA mapped to the \\ coordinate pair | | MSA_Fip_Code | `str` | code given by the census to describe the \\ coordinate pair area - useful when mapping to other sources | Raises: ValueError: Coordinates must either be a list of tuples with two floats in each element or a single tuple with two floats. Examples: Function can be applied to a single coordinate pair or a list of coordinates and is robust to empty values: >>> from msa_mapper import map_census_locations >>> dc_lonlat = (-77.03637, 38.9072) >>> map_census_locations(dc_lonlat) \"\"\" assert (( isinstance ( coords , list ) and all ( x is None or type ( x ) == tuple for x in coords ) and all ( type ( x ) == float for x in list ( chain ( * [[( m ) for m in x ] for x in coords if x is not None ]))) and all ( x is None or len ( x ) == 2 for x in coords )) or ( isinstance ( coords , tuple ) and all ( type ( x ) == float for x in coords ) and len ( coords ) == 2 )), \\ ValueError ( \"Coordinates must either be a list of tuples with two\" + \" floats in each element or a single tuple with two\" + \" floats. Example [(0.2, 0.4), (0.5, 0.6)] or\" + \" (0.2, 0.4).\" ) metdiv_gdf = _get_mapping_files ( 'metdiv' )[ 0 ] cbsa_gdf , cbsa_crs = _get_mapping_files ( 'cbsa' ) if type ( coords ) == list : lonlat_gdf_cbsa = ( gpd . GeoDataFrame ({ \"geometry\" : [ Point ( x ) if x is not None else None for x in coords ]}, crs = cbsa_crs ) ) else : lonlat_gdf_cbsa = ( gpd . GeoDataFrame ({ \"geometry\" : [ Point ( coords )]}, crs = cbsa_crs ) ) subset_metdiv = metdiv_gdf [[ \"geometry\" , \"NAME\" , \"METDIVFP\" , \"CBSAFP\" ]] subset_cbsa = cbsa_gdf [[ \"geometry\" , \"NAME\" , \"CBSAFP\" ]] lonlat_metdiv_joined = ( gpd . sjoin ( lonlat_gdf_cbsa , subset_metdiv , how = 'left' , predicate = 'within' ) . drop ( \"index_right\" , axis = 1 ) ) all_joined = ( gpd . sjoin ( lonlat_metdiv_joined , subset_cbsa , how = 'left' , predicate = 'within' ) . drop ( \"index_right\" , axis = 1 ) ) all_joined [ \"MSA_Name\" ] = ( np . select ( [( all_joined [ \"NAME_left\" ] . notnull ()), ( all_joined [ \"NAME_left\" ] . isnull ())], [( all_joined [ \"NAME_left\" ]), ( all_joined [ \"NAME_right\" ])]) ) all_joined [ \"MSA_Fip_Code\" ] = ( np . select ( [( all_joined [ \"METDIVFP\" ] . notnull ()), ( all_joined [ \"METDIVFP\" ] . isnull ())], [( all_joined [ \"METDIVFP\" ]), ( all_joined [ \"CBSAFP_right\" ])]) ) all_joined = ( all_joined [[ \"geometry\" , \"MSA_Name\" , \"MSA_Fip_Code\" ]] . rename ( columns = { \"geometry\" : \"Coordinates\" }) ) return all_joined","title":"Census MSA Mapping"},{"location":"modules/census_msa/#census-msa-mapping","text":"","title":"Census MSA Mapping"},{"location":"modules/census_msa/#msa_mapper.census_msa.map_census_locations","text":"Given a list of longitude/latitude coordinate pairs or a single pair, this function will map the locations to the census-defined Metropolitan Statistical Area (MSA). Parameters: Name Type Description Default coords tuple or list[tuple] either a single coordinate pair or a list of longitude/latitude coordinates required Returns: This function returns a geopandas.geodataframe.GeoDataFrame with the following columns Column Type Description Coordinates shapely.geometry.Point coordinates passed to the function as a shapely geometry MSA_Name str name given by the census to the MSA mapped to the coordinate pair MSA_Fip_Code str code given by the census to describe the coordinate pair area - useful when mapping to other sources Exceptions: Type Description ValueError Coordinates must either be a list of tuples with two floats in each element or a single tuple with two floats. Examples: Function can be applied to a single coordinate pair or a list of coordinates and is robust to empty values: >>> from msa_mapper import map_census_locations >>> dc_lonlat = ( - 77.03637 , 38.9072 ) >>> map_census_locations ( dc_lonlat ) Source code in msa_mapper/census_msa.py def map_census_locations ( coords ): \"\"\" Given a list of longitude/latitude coordinate pairs or a single pair, this function will map the locations to the census-defined Metropolitan Statistical Area (MSA). Args: coords (tuple or list[tuple]): either a single coordinate pair or a list of longitude/latitude coordinates **Returns:** This function returns a geopandas.geodataframe.GeoDataFrame with the following columns | Column | Type | Description | | :----- | :--- | :---------- | | Coordinates | `shapely.geometry.Point`| coordinates \\ passed to the function as a shapely geometry | | MSA_Name | `str` | name given by the census to the MSA mapped to the \\ coordinate pair | | MSA_Fip_Code | `str` | code given by the census to describe the \\ coordinate pair area - useful when mapping to other sources | Raises: ValueError: Coordinates must either be a list of tuples with two floats in each element or a single tuple with two floats. Examples: Function can be applied to a single coordinate pair or a list of coordinates and is robust to empty values: >>> from msa_mapper import map_census_locations >>> dc_lonlat = (-77.03637, 38.9072) >>> map_census_locations(dc_lonlat) \"\"\" assert (( isinstance ( coords , list ) and all ( x is None or type ( x ) == tuple for x in coords ) and all ( type ( x ) == float for x in list ( chain ( * [[( m ) for m in x ] for x in coords if x is not None ]))) and all ( x is None or len ( x ) == 2 for x in coords )) or ( isinstance ( coords , tuple ) and all ( type ( x ) == float for x in coords ) and len ( coords ) == 2 )), \\ ValueError ( \"Coordinates must either be a list of tuples with two\" + \" floats in each element or a single tuple with two\" + \" floats. Example [(0.2, 0.4), (0.5, 0.6)] or\" + \" (0.2, 0.4).\" ) metdiv_gdf = _get_mapping_files ( 'metdiv' )[ 0 ] cbsa_gdf , cbsa_crs = _get_mapping_files ( 'cbsa' ) if type ( coords ) == list : lonlat_gdf_cbsa = ( gpd . GeoDataFrame ({ \"geometry\" : [ Point ( x ) if x is not None else None for x in coords ]}, crs = cbsa_crs ) ) else : lonlat_gdf_cbsa = ( gpd . GeoDataFrame ({ \"geometry\" : [ Point ( coords )]}, crs = cbsa_crs ) ) subset_metdiv = metdiv_gdf [[ \"geometry\" , \"NAME\" , \"METDIVFP\" , \"CBSAFP\" ]] subset_cbsa = cbsa_gdf [[ \"geometry\" , \"NAME\" , \"CBSAFP\" ]] lonlat_metdiv_joined = ( gpd . sjoin ( lonlat_gdf_cbsa , subset_metdiv , how = 'left' , predicate = 'within' ) . drop ( \"index_right\" , axis = 1 ) ) all_joined = ( gpd . sjoin ( lonlat_metdiv_joined , subset_cbsa , how = 'left' , predicate = 'within' ) . drop ( \"index_right\" , axis = 1 ) ) all_joined [ \"MSA_Name\" ] = ( np . select ( [( all_joined [ \"NAME_left\" ] . notnull ()), ( all_joined [ \"NAME_left\" ] . isnull ())], [( all_joined [ \"NAME_left\" ]), ( all_joined [ \"NAME_right\" ])]) ) all_joined [ \"MSA_Fip_Code\" ] = ( np . select ( [( all_joined [ \"METDIVFP\" ] . notnull ()), ( all_joined [ \"METDIVFP\" ] . isnull ())], [( all_joined [ \"METDIVFP\" ]), ( all_joined [ \"CBSAFP_right\" ])]) ) all_joined = ( all_joined [[ \"geometry\" , \"MSA_Name\" , \"MSA_Fip_Code\" ]] . rename ( columns = { \"geometry\" : \"Coordinates\" }) ) return all_joined","title":"map_census_locations()"},{"location":"modules/geocoder/","text":"Geographic Decoder \u00b6 get_geoinfo ( address , city = None , state = None ) \u00b6 Given a street address, city, and state, this function will call the ArcGIS API and geocode the location - returning the full address and the longitude/latitude coordinate pair for the mapped location. Function will automatically convert all parameters to strings. Parameters: Name Type Description Default address object street address for the location to geocode required city object the U.S. city the location is located in None state object the U.S. state the location is located in None Returns: Type Description list[str, tuple] list containing [0] the official address obtained from the ArcGIS API, and [1] the longitute/latitude coordinate pair Examples: To geocode a single street address: >>> from msa_mapper import get_geoinfo >>> get_geoinfo ( '801 Grand Ave' , 'Des Moines' ) Out [ 1 ]: [ '801 Grand Ave, Des Moines, IA 50309' , ... ( - 93.6285390023275 , 41.58744200206709 )] To geocode multiple addresses stored in a pandas DataFrame ( addresses_pdf ) with columns for each parameter ( Address , City , State ), we recommend installing and importing pandarallel to parallelize the apply function: >>> import multiprocessing >>> from pandarallel import pandarallel >>> num_cores = multiprocessing . cpu_count () >>> pandarallel . initialize ( progress_bar = True , ... nb_workers = ( num_cores - 1 )) >>> def func_name ( x ): ... from msa_mapper import get_geoinfo ... return get_geoinfo ( x . Address , x . City , x . State ) >>> res = ( ... addresses_pdf ... . parallel_apply ( func_name , axis = 1 ) ... ) >>> addresses = res . str [ 0 ] . tolist () >>> coords = res . str [ 1 ] . tolist () Source code in msa_mapper/geocoder.py def get_geoinfo ( address , city = None , state = None ): \"\"\" Given a street address, city, and state, this function will call the ArcGIS API and geocode the location - returning the full address and the longitude/latitude coordinate pair for the mapped location. Function will automatically convert all parameters to strings. Args: address (object): street address for the location to geocode city (object): the U.S. city the location is located in state (object): the U.S. state the location is located in Returns: list[str, tuple]: list containing [0] the official address obtained from the ArcGIS API, and [1] the longitute/latitude coordinate pair Example: To geocode a single street address: >>> from msa_mapper import get_geoinfo >>> get_geoinfo('801 Grand Ave', 'Des Moines') Out[1]: ['801 Grand Ave, Des Moines, IA 50309', ... (-93.6285390023275, 41.58744200206709)] To geocode multiple addresses stored in a pandas DataFrame (`addresses_pdf`) with columns for each parameter (`Address`, `City`, `State`), we recommend installing and importing `pandarallel` to parallelize the apply function: >>> import multiprocessing >>> from pandarallel import pandarallel >>> num_cores = multiprocessing.cpu_count() >>> pandarallel.initialize(progress_bar=True, ... nb_workers=(num_cores - 1)) >>> def func_name(x): ... from msa_mapper import get_geoinfo ... return get_geoinfo(x.Address, x.City, x.State) >>> res = ( ... addresses_pdf ... .parallel_apply(func_name, axis=1) ... ) >>> addresses = res.str[0].tolist() >>> coords = res.str[1].tolist() \"\"\" if address : address = ( str ( address ) . split ( '-' )[ - 1 ] . split ( '&' )[ - 1 ] . split ( ';' )[ - 1 ] . strip () . encode ( 'ascii' , errors = 'ignore' ) . decode () ) city_filtered = str ( city ) . lower () . strip () if city and city_filtered not in ( 'vr' , 'various' ): city = city_filtered . encode ( 'ascii' , errors = 'ignore' ) . decode () else : city = None state_filtered = str ( state ) . upper () . strip () if state and state_filtered in state_mapping () . keys (): state = ( state_filtered . encode ( 'ascii' , errors = 'ignore' ) . decode () ) else : state = None search = ', ' . join ( id for id in [ address , city , state ] if id ) response = geocoder . arcgis ( search , timeout = 30 ) if response . ok : return _obtain_attributes ( response ) else : time . sleep ( 3 ) response = geocoder . arcgis ( search , timeout = 30 ) if response . ok : return _obtain_attributes ( response ) else : return None","title":"Geographic Decoder"},{"location":"modules/geocoder/#geographic-decoder","text":"","title":"Geographic Decoder"},{"location":"modules/geocoder/#msa_mapper.geocoder.get_geoinfo","text":"Given a street address, city, and state, this function will call the ArcGIS API and geocode the location - returning the full address and the longitude/latitude coordinate pair for the mapped location. Function will automatically convert all parameters to strings. Parameters: Name Type Description Default address object street address for the location to geocode required city object the U.S. city the location is located in None state object the U.S. state the location is located in None Returns: Type Description list[str, tuple] list containing [0] the official address obtained from the ArcGIS API, and [1] the longitute/latitude coordinate pair Examples: To geocode a single street address: >>> from msa_mapper import get_geoinfo >>> get_geoinfo ( '801 Grand Ave' , 'Des Moines' ) Out [ 1 ]: [ '801 Grand Ave, Des Moines, IA 50309' , ... ( - 93.6285390023275 , 41.58744200206709 )] To geocode multiple addresses stored in a pandas DataFrame ( addresses_pdf ) with columns for each parameter ( Address , City , State ), we recommend installing and importing pandarallel to parallelize the apply function: >>> import multiprocessing >>> from pandarallel import pandarallel >>> num_cores = multiprocessing . cpu_count () >>> pandarallel . initialize ( progress_bar = True , ... nb_workers = ( num_cores - 1 )) >>> def func_name ( x ): ... from msa_mapper import get_geoinfo ... return get_geoinfo ( x . Address , x . City , x . State ) >>> res = ( ... addresses_pdf ... . parallel_apply ( func_name , axis = 1 ) ... ) >>> addresses = res . str [ 0 ] . tolist () >>> coords = res . str [ 1 ] . tolist () Source code in msa_mapper/geocoder.py def get_geoinfo ( address , city = None , state = None ): \"\"\" Given a street address, city, and state, this function will call the ArcGIS API and geocode the location - returning the full address and the longitude/latitude coordinate pair for the mapped location. Function will automatically convert all parameters to strings. Args: address (object): street address for the location to geocode city (object): the U.S. city the location is located in state (object): the U.S. state the location is located in Returns: list[str, tuple]: list containing [0] the official address obtained from the ArcGIS API, and [1] the longitute/latitude coordinate pair Example: To geocode a single street address: >>> from msa_mapper import get_geoinfo >>> get_geoinfo('801 Grand Ave', 'Des Moines') Out[1]: ['801 Grand Ave, Des Moines, IA 50309', ... (-93.6285390023275, 41.58744200206709)] To geocode multiple addresses stored in a pandas DataFrame (`addresses_pdf`) with columns for each parameter (`Address`, `City`, `State`), we recommend installing and importing `pandarallel` to parallelize the apply function: >>> import multiprocessing >>> from pandarallel import pandarallel >>> num_cores = multiprocessing.cpu_count() >>> pandarallel.initialize(progress_bar=True, ... nb_workers=(num_cores - 1)) >>> def func_name(x): ... from msa_mapper import get_geoinfo ... return get_geoinfo(x.Address, x.City, x.State) >>> res = ( ... addresses_pdf ... .parallel_apply(func_name, axis=1) ... ) >>> addresses = res.str[0].tolist() >>> coords = res.str[1].tolist() \"\"\" if address : address = ( str ( address ) . split ( '-' )[ - 1 ] . split ( '&' )[ - 1 ] . split ( ';' )[ - 1 ] . strip () . encode ( 'ascii' , errors = 'ignore' ) . decode () ) city_filtered = str ( city ) . lower () . strip () if city and city_filtered not in ( 'vr' , 'various' ): city = city_filtered . encode ( 'ascii' , errors = 'ignore' ) . decode () else : city = None state_filtered = str ( state ) . upper () . strip () if state and state_filtered in state_mapping () . keys (): state = ( state_filtered . encode ( 'ascii' , errors = 'ignore' ) . decode () ) else : state = None search = ', ' . join ( id for id in [ address , city , state ] if id ) response = geocoder . arcgis ( search , timeout = 30 ) if response . ok : return _obtain_attributes ( response ) else : time . sleep ( 3 ) response = geocoder . arcgis ( search , timeout = 30 ) if response . ok : return _obtain_attributes ( response ) else : return None","title":"get_geoinfo()"}]}